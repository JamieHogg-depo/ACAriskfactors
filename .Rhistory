x.out <- x.out[keep]
y.out <- y.out[keep]
# Duplicate end value with zero y values to ensure correct shading of wave plot
x.out <- c(x.out[1], x.out, x.out[7])
y.out <- c(0, y.out, 0)
# add to dataset
temp.wave <- rbind(temp.wave, c(x.out, y.out))
# progress bar
if(verbose)setTxtProgressBar(pb, i)
} # end for loop
if(verbose)close(pb)
# Round wave x-values to 2 dp
temp.wave[, 1:9] <- sapply(temp.wave[, 1:9], round, digits = 2)
# Round wave y-values to 3 dp
temp.wave[, 10:18] <- sapply(temp.wave[, 10:18], round, digits = 3)
# Concatenate wave x and y values into strings
temp1 <- apply(temp.wave[,1:9], 1, paste, collapse = ",")
temp2 <- apply(temp.wave[,10:18], 1, paste, collapse = ",")
temp.wave <- cbind(temp1, temp2)
colnames(temp.wave) <- c("xValues", "yValues")
# return dataframe
return(as.data.frame(temp.wave) %>% setNames(paste0(prefix, names(.))))
}
getWavePlotVars(matrix(runif(10000), ncol = 5))
getWavePlotVars(matrix(runif(10000, -1, 1), ncol = 5))
#' @title getWavePlotVars
#' @param draws matrix (iterations x observations) of posterior draws
#' @param prefix (defaults to "") character vector that will be appended to
#' the start of the column names.
#' @param verbose (defaults to FALSE) reports progress of operation.
#' @param truncation_upper (defaults to 4) truncation of density approximation of
#' ratios. With a value of 4, density evaluations above 4 and below 1/4 are removed.
#' @returns Dataframe (observations x 2) with `xValues` and `yValues`
#' #' WARNING: Only use with relative measures where 1 is a meaningful middle value.
#' #' NOTE: `draws` should NOT be log-transformed - the function will perform this action.
getWavePlotVars <- function(draws, prefix = "", verbose = FALSE, truncation_upper = 4){
if(any(draws < 0))
stop(paste0("Ensure all values in ", deparse(substitute(draws)), " are positive..."))
# create empty data.frame
temp.wave <- NULL
# loop through each column of `draws`
if(verbose){pb <- txtProgressBar(min = 0, max = ncol(draws), style = 3)}
for(i in 1:ncol(draws)){
# set truncation amount
truncation <- c(1/truncation_upper, truncation_upper)
# Initial density estimation
f <- density(log(draws[,i]), n = 128)
x.out <- f$x
y.out <- f$y
# truncate densities
keep <- which(x.out > log(truncation[1]) & x.out < log(truncation[2]))
# select points
if(length(keep) > 0){
x.out <- x.out[keep]
y.out <- y.out[keep]
# Identify mode and points at strategic y values
n2 <- length(x.out)
Mode <- which.max(y.out)
h85 <- abs(y.out[Mode] * 0.85 - y.out)
h10 <- abs(y.out[Mode] * 0.1 - y.out)
zeros <- y.out
zeros[which(zeros < y.out[Mode] * 0.002)] <- Inf
# Set left points
if(Mode == 1){
h85.L <- Mode
h10.L <- Mode
Min <- Mode
}else{
h85.L <- which.min(h85[1:(Mode - 1)])
h10.L <- which.min(h10[1:(Mode - 1)])
Min <- which.min(zeros[1:(Mode - 1)])
}
# Set right points
if(Mode == n2){
h85.R <- Mode
h10.R <- Mode
Max <- Mode
}else{
h85.R <- which.min(h85[(Mode + 1):n2]) + Mode
h10.R <- which.min(h10[(Mode + 1):n2]) + Mode
Max <- which.min(zeros[(Mode + 1):n2]) + Mode
}
keep <- c(Min, h10.L, h85.L, Mode, h85.R, h10.R, Max)
}else{
keep <- which.max(y.out)
if(keep < n){   # Stack at lower truncation
keep <- 1:7
x.out <- rep(log(truncation[1]), 7)
}else{          # Stack at upper truncation
keep <- (n-6):n
x.out <- rep(log(truncation[2]), 7)
}
y.out <- y.out[keep]
}
# Reduce to 7 points
x.out <- x.out[keep]
y.out <- y.out[keep]
# Duplicate end value with zero y values to ensure correct shading of wave plot
x.out <- c(x.out[1], x.out, x.out[7])
y.out <- c(0, y.out, 0)
# add to dataset
temp.wave <- rbind(temp.wave, c(x.out, y.out))
# progress bar
if(verbose)setTxtProgressBar(pb, i)
} # end for loop
if(verbose)close(pb)
# Round wave x-values to 2 dp
temp.wave[, 1:9] <- sapply(temp.wave[, 1:9], round, digits = 2)
# Round wave y-values to 3 dp
temp.wave[, 10:18] <- sapply(temp.wave[, 10:18], round, digits = 3)
# Concatenate wave x and y values into strings
temp1 <- apply(temp.wave[,1:9], 1, paste, collapse = ",")
temp2 <- apply(temp.wave[,10:18], 1, paste, collapse = ",")
temp.wave <- cbind(temp1, temp2)
colnames(temp.wave) <- c("xValues", "yValues")
# return dataframe
return(as.data.frame(temp.wave) %>% setNames(paste0(prefix, names(.))))
}
getWavePlotVars(matrix(runif(10000, -1, 1), ncol = 5))
getWavePlotVars(test <- matrix(runif(10000, -1, 1), ncol = 5))
test <- matrix(runif(10000, -1, 1), ncol = 5)
getWavePlotVars(test)
#' @title getWavePlotVars
#' @param draws matrix (iterations x observations) of posterior draws
#' @param prefix (defaults to "") character vector that will be appended to
#' the start of the column names.
#' @param verbose (defaults to FALSE) reports progress of operation.
#' @param truncation_upper (defaults to 4) truncation of density approximation of
#' ratios. With a value of 4, density evaluations above 4 and below 1/4 are removed.
#' @returns Dataframe (observations x 2) with `xValues` and `yValues`
#' #' WARNING: Only use with relative measures where 1 is a meaningful middle value.
#' #' NOTE: `draws` should NOT be log-transformed - the function will perform this action.
getWavePlotVars <- function(draws, prefix = "", verbose = FALSE, truncation_upper = 4){
if(any(draws < 0))
stop(paste0("Ensure all values in `", deparse(substitute(draws)), "` are positive..."))
# create empty data.frame
temp.wave <- NULL
# loop through each column of `draws`
if(verbose){pb <- txtProgressBar(min = 0, max = ncol(draws), style = 3)}
for(i in 1:ncol(draws)){
# set truncation amount
truncation <- c(1/truncation_upper, truncation_upper)
# Initial density estimation
f <- density(log(draws[,i]), n = 128)
x.out <- f$x
y.out <- f$y
# truncate densities
keep <- which(x.out > log(truncation[1]) & x.out < log(truncation[2]))
# select points
if(length(keep) > 0){
x.out <- x.out[keep]
y.out <- y.out[keep]
# Identify mode and points at strategic y values
n2 <- length(x.out)
Mode <- which.max(y.out)
h85 <- abs(y.out[Mode] * 0.85 - y.out)
h10 <- abs(y.out[Mode] * 0.1 - y.out)
zeros <- y.out
zeros[which(zeros < y.out[Mode] * 0.002)] <- Inf
# Set left points
if(Mode == 1){
h85.L <- Mode
h10.L <- Mode
Min <- Mode
}else{
h85.L <- which.min(h85[1:(Mode - 1)])
h10.L <- which.min(h10[1:(Mode - 1)])
Min <- which.min(zeros[1:(Mode - 1)])
}
# Set right points
if(Mode == n2){
h85.R <- Mode
h10.R <- Mode
Max <- Mode
}else{
h85.R <- which.min(h85[(Mode + 1):n2]) + Mode
h10.R <- which.min(h10[(Mode + 1):n2]) + Mode
Max <- which.min(zeros[(Mode + 1):n2]) + Mode
}
keep <- c(Min, h10.L, h85.L, Mode, h85.R, h10.R, Max)
}else{
keep <- which.max(y.out)
if(keep < n){   # Stack at lower truncation
keep <- 1:7
x.out <- rep(log(truncation[1]), 7)
}else{          # Stack at upper truncation
keep <- (n-6):n
x.out <- rep(log(truncation[2]), 7)
}
y.out <- y.out[keep]
}
# Reduce to 7 points
x.out <- x.out[keep]
y.out <- y.out[keep]
# Duplicate end value with zero y values to ensure correct shading of wave plot
x.out <- c(x.out[1], x.out, x.out[7])
y.out <- c(0, y.out, 0)
# add to dataset
temp.wave <- rbind(temp.wave, c(x.out, y.out))
# progress bar
if(verbose)setTxtProgressBar(pb, i)
} # end for loop
if(verbose)close(pb)
# Round wave x-values to 2 dp
temp.wave[, 1:9] <- sapply(temp.wave[, 1:9], round, digits = 2)
# Round wave y-values to 3 dp
temp.wave[, 10:18] <- sapply(temp.wave[, 10:18], round, digits = 3)
# Concatenate wave x and y values into strings
temp1 <- apply(temp.wave[,1:9], 1, paste, collapse = ",")
temp2 <- apply(temp.wave[,10:18], 1, paste, collapse = ",")
temp.wave <- cbind(temp1, temp2)
colnames(temp.wave) <- c("xValues", "yValues")
# return dataframe
return(as.data.frame(temp.wave) %>% setNames(paste0(prefix, names(.))))
}
getWavePlotVars(test)
test <- matrix(runif(10000), ncol = 5)
getWavePlotVars(test)
## -----------------------------------------------------------------------------
## Setup ## --------------------------------------------------------------------
## -----------------------------------------------------------------------------
# Packages
library(tidyverse)
library(scales)
library(sf)
library(MASS)
library(patchwork)
library(readr)
library(readxl)
library(grid)
library(gridExtra)
library(Matrix)
rm(list = ls())
base_folder <- "C:/r_proj/ACAriskfactors/out"
## Functions ## ----------------------------------------------------------------
source('src/wrangle/functions_ALL.R')
source('src/wrangle/moreFuns.R')
## Load Data ## ----------------------------------------------------------------
# Load global data
global_obj <- readRDS("data/DataLabExport/global_obj.rds")
listw <- mat2listw(global_obj$W)
# Load raw estimates
raw_est <- pbapply::pblapply(list.files("data/DataLabExport",
pattern = "raw_est_*", full.names = T), readRDS)
names(raw_est) <- str_remove(
str_remove(
list.files("data/DataLabExport", pattern = "raw_est_*"), "raw_est_"), ".rds")
# Load all modelled estimates
summsa2all <- readRDS("data/summary_files/summsa2all.rds")
# Model building
model_building <- lapply(list.files("data/DataLabExport",
pattern = "model_building_*", full.names = T), readRDS)
names(model_building) <- str_remove(
str_remove(
list.files("data/DataLabExport", pattern = "model_building_*"), "model_building_"), ".rds")
# Load map
map_sa2_full <- st_read("C:/r_proj/ACAriskfactors/data/2016_SA2_Shape_min/2016_SA2_Shape_min.shp") %>%
mutate(SA2 = as.numeric(SA2_MAIN16)) %>%
filter(!str_detect(SA2_NAME, "Island")) %>%
filter(STATE_NAME != "Other Territories")
# keep non-estimated geometries
map_sa2 <- map_sa2_full %>%
left_join(.,global_obj$area_concor, by = "SA2")
# Australia outline
aus_border <- suppressMessages(map_sa2 %>%
summarise(geometry = st_union(geometry)) %>%
st_as_sf() %>%
st_transform(4326))
# State outline
state_border <- suppressMessages(map_sa2 %>%
mutate(state = str_sub(SA2, 1, 1)) %>%
group_by(state, STATE_NAME) %>%
summarise(geometry = st_union(geometry), .groups = "drop") %>%
filter(!st_is_empty(.)) %>%
#mutate(st_init = c("NSW", "VIC", "QLD", "SA", "WA", NA, "NT", NA)) %>%
st_as_sf() %>%
st_transform(4326))
## Other code ## --------------------------------------------------------------
# City Insets
lims <- data.frame(
xmin = c(152.6, 150.35, 144.5, 115.45, 138.1, 146.8, 148.6, 130.3),
xmax = c(153.6, 151.35, 145.5, 116.45, 139.1, 147.8, 149.6, 131.3),
ymin = -c(28, 34.4, 38.4, 32.5, 35.4, 43.4, 35.8, 13),
ymax = -c(27, 33.4, 37.4, 31.5, 34.4, 42.4, 34.8, 12),
city = c("Brisbane", "Sydney", "Melbourne", "Perth", "Adelaide", "Hobart", "Canberra", "Darwin"),
position = c("r", "r", "b", "l", "b", "b", "r", "l"),
inset_labs = c("B - Brisbane (Qld)", "S - Sydney (NSW)",
"M - Melbourne (Vic)", "P - Perth (WA)",
"A - Adelaide (SA)", "H - Hobart (Tas)",
"C - Canberra (ACT)", "D - Darwin (NT)")
) %>%
mutate(initials = str_sub(city, 1, 1))
# quantiles for IRSD
irsd_5c <- mutate(global_obj$census,
irsd_5c = case_when(
ABS_irsd_decile_nation_complete %in% c("1", "2") ~ "1 - most\ndisadvantaged",
ABS_irsd_decile_nation_complete %in% c("3", "4") ~ "2",
ABS_irsd_decile_nation_complete %in% c("5", "6") ~ "3",
ABS_irsd_decile_nation_complete %in% c("7", "8") ~ "4",
ABS_irsd_decile_nation_complete %in% c("9", "10") ~ "5 - least\ndisadvantaged"
)) %>%
dplyr::select(ps_area, irsd_5c)
# Full names
lookup <- data.frame(rf = names(raw_est),
rf_full = c("Leisure physical activity",
"All physical activity",
"Alcohol",
"Diet",
"Obesity",
"Overweight",
"Current smoking",
"Risky waist circumference"))
# Full names2
lookup <- data.frame(rf = names(raw_est),
sha = c("exercise", "exercise", "alcohol",
"fruit", "obese", "overweight",
"smoking", "overweight"),
rf_full = c("Inadequate physical activity (leisure)",
"Inadequate physical activity (all)",
"Risky alcohol consumption",
"Inadequate diet",
"Obesity",
"Overweight",
"Current smoking",
"Risky waist circumference"))
## Load PHA SHA data ## --------------------------------------------------------
source("src/wrangle/getSHA.R")
## Load census data ## ---------------------------------------------------------
source("src/wrangle/loadCensusData.R")
## END SCRIPT ## --------------------------------------------------------------
modelled_est <- readRDS("C:/r_proj/ACAriskfactors/data/summary_files/smoking_b1.rds")
cut_offs <- c(1/2, 2)
mapping_data <- modelled_est$summ$sa2_map %>%
mutate() %>%
mutate(or_median = ifelse(or_median > cut_offs[2], cut_offs[2], or_median),
or_median = ifelse(or_median < cut_offs[1], cut_offs[1], or_median))
# define fill colours
Fill.colours <- c("#2C7BB6", "#2C7BB6", "#ABD9E9", "#FFFFBF", "#FDAE61", "#D7191C", "#D7191C")
End <- log(2.1)
Breaks.fill <- c(1/2, 1/1.5, 1, 1.5, 2)
Fill.values <- c(-End, log(Breaks.fill), End)
# base map
mapping_data %>%
ggplot(aes(fill = log(or_median)))+
theme_void()+
geom_sf(col = NA)+
scale_fill_gradientn(colors = Fill.colours,
values = rescale(Fill.values),
labels = as.character(round(Breaks.fill, 3)),
breaks = log(Breaks.fill),
limits = range(Fill.values))+
geom_sf(data = aus_border, aes(geometry = geometry),
colour = "black", fill = NA, size = 0.2)+
geom_sf(data = state_border, aes(geometry = geometry),
colour = "black", fill = NA, size = 0.1)+
theme(text = element_text(size = 8),
plot.title = element_text(margin = margin(0,0,2,0)),
plot.margin = unit(c(1,1,1,1), "mm"))
cut_offs <- c(1/2, 2)
mapping_data <- modelled_est$summ$sa2_map %>%
mutate() %>%
mutate(or_median = ifelse(or_median > cut_offs[2], cut_offs[2], or_median),
or_median = ifelse(or_median < cut_offs[1], cut_offs[1], or_median))
# define fill colours
Fill.colours <- c("#2C7BB6", "#2C7BB6", "#ABD9E9", "#FFFFBF", "#FDAE61", "#D7191C", "#D7191C")
End <- log2(2.1)
Breaks.fill <- c(1/2, 1/1.5, 1, 1.5, 2)
Fill.values <- c(-End, log2(Breaks.fill), End)
# base map
mapping_data %>%
ggplot(aes(fill = log2(or_median)))+
theme_void()+
geom_sf(col = NA)+
scale_fill_gradientn(colors = Fill.colours,
values = rescale(Fill.values),
labels = as.character(round(Breaks.fill, 3)),
breaks = log2(Breaks.fill),
limits = range(Fill.values))+
geom_sf(data = aus_border, aes(geometry = geometry),
colour = "black", fill = NA, size = 0.2)+
geom_sf(data = state_border, aes(geometry = geometry),
colour = "black", fill = NA, size = 0.1)+
theme(text = element_text(size = 8),
plot.title = element_text(margin = margin(0,0,2,0)),
plot.margin = unit(c(1,1,1,1), "mm"))
# Packages
library(tidyverse)
library(readr)
library(readxl)
library(sf)
library(openxlsx)
rm(list = ls())
## Functions ## ----------------------------------------------------------------
source('src/wrangle/functions_ALL.R')
source('src/wrangle/moreFuns.R')
# Load global data
global_obj <- readRDS("data/DataLabExport/global_obj.rds")
# Load raw estimates
raw_est <- pbapply::pblapply(list.files("data/DataLabExport",
pattern = "raw_est_*", full.names = T), readRDS)
names(raw_est) <- str_remove(
str_remove(
list.files("data/DataLabExport", pattern = "raw_est_*"), "raw_est_"), ".rds")
# load map
map_sa2_full <- st_read("C:/r_proj/ACAriskfactors/data/2016_SA2_Shape_min/2016_SA2_Shape_min.shp") %>%
mutate(SA2 = as.numeric(SA2_MAIN16)) %>%
filter(!str_detect(SA2_NAME, "Island")) %>%
filter(STATE_NAME != "Other Territories") %>%
dplyr::select(SA2_MAIN16, SA2_NAME) %>%
st_drop_geometry() %>%
rename(SA2 = SA2_MAIN16,
SA2_name = SA2_NAME) %>%
mutate(SA2 = as.numeric(SA2))
# Load all modelled estimates
summsa2all <- readRDS("data/summary_files/summsa2all.rds")
## START FOR LOOP #### ---------------------------------------------------------
out <- list()
for(k in 1:8){
rf <- names(raw_est)[k]
message("Started ", k, ": ", rf)
# load data
modelled_est <- readRDS(file = paste0("data/DataLabExport/modelled_est_", rf, ".rds"))
modelled_est$rr <- modelled_est$mu/raw_est[[k]]$national[1]
# get mu quantiles
mu_quants <- bind_rows(lapply(asplit(modelled_est$mu, 2),
quantile, p = c(0.1,0.2,0.5,0.8,0.9), na.rm = T)) %>%
setNames(paste0("mu_", c("p10", "p20", "p50", "p80", "p90")))
# get OR quantiles
or_quants <- bind_rows(lapply(asplit(modelled_est$or, 2),
quantile, p = c(0.1,0.2,0.5,0.8,0.9), na.rm = T)) %>%
setNames(paste0("or_", c("p10", "p20", "p50", "p80", "p90")))
# get logOR quantiles
logor_quants <- bind_rows(lapply(asplit(log2(modelled_est$or), 2),
quantile, p = c(0.1,0.2,0.5,0.8,0.9), na.rm = T)) %>%
setNames(paste0("or_", c("logp10", "logp20", "logp50", "logp80", "logp90")))
# get OR quantiles
rr_quants <- bind_rows(lapply(asplit(modelled_est$rr, 2),
quantile, p = c(0.1,0.2,0.5,0.8,0.9), na.rm = T)) %>%
setNames(paste0("rr_", c("p10", "p20", "p50", "p80", "p90")))
# get logOR quantiles
logrr_quants <- bind_rows(lapply(asplit(log2(modelled_est$rr), 2),
quantile, p = c(0.1,0.2,0.5,0.8,0.9), na.rm = T)) %>%
setNames(paste0("rr_", c("logp10", "logp20", "logp50", "logp80", "logp90")))
# get wave plot
or_wave <- getWavePlotVars(modelled_est$or, prefix = "or_")
rr_wave <- getWavePlotVars(modelled_est$rr, prefix = "rr_")
# V-plot - exceedance probability
v <- bind_cols(getDPP(modelled_est$or, null_value = 1)) %>%
dplyr::select(EP, DPP) %>%
mutate(bivariate_cat = case_when(
EP >= 0.8 ~ "High",
EP <= 0.2 ~ "Low",
EP > 0.2 & EP < 0.8 ~ "Unclear"
)) %>%
dplyr::select(bivariate_cat, DPP) %>%
setNames(c("bivariate_cat", "v"))
# add all colums
out[[k]] <- cbind(dplyr::select(global_obj$area_concor, SA2),
or_quants, logor_quants, or_wave,
v,
mu_quants,
rr_quants, logrr_quants, rr_wave) %>%
mutate(riskfactorgrp = rf) %>%
left_join(., map_sa2_full, by = "SA2") %>%
rename(SA2_code = SA2)
# cleanup
rm(modelled_est, mu_quants, or_quants, logor_quants, v, or_wave, rr_wave,
rr_quants, logrr_quants)
## FINISH FOR LOOP #### --------------------------------------------------------
}
# save R version
full_data <- bind_rows(out) %>%
mutate(indicator = "riskfactor",
level = "",
sex = "Persons",
years = "2017-2018",
baseline = "national_average") %>%
relocate(indicator, level, sex, riskfactorgrp, years, baseline, SA2_code, SA2_name)
saveRDS(full_data, "data/ViseR_Input_Data/riskfactor_estimates.rds")
smoking_b1 <- readRDS("C:/r_proj/ACAriskfactors/data/summary_files/smoking_b1.rds")
smoking_b1_full <- readRDS("C:/r_proj/ACAriskfactors/data/summary_files/smoking_b1_full.rds")
data.frame(or = smoking_b1_full$draws$or[,1],
logor = log(smoking_b1_full$draws$or[,1]),
log2or = log2(smoking_b1_full$draws$or[,1])) %>%
pivot_longer(everything())
data.frame(or = smoking_b1_full$draws$or[,1],
logor = log(smoking_b1_full$draws$or[,1]),
log2or = log2(smoking_b1_full$draws$or[,1])) %>%
pivot_longer(everything()) %>%
ggplot(aes(x = value, col = name))+
geom_density()
data.frame(or = smoking_b1_full$draws$or[,2],
logor = log(smoking_b1_full$draws$or[,2]),
log2or = log2(smoking_b1_full$draws$or[,2])) %>%
pivot_longer(everything()) %>%
ggplot(aes(x = value, col = name))+
geom_density()
data.frame(or = smoking_b1_full$draws$or[,2],
rr = smoking_b1_full$draws$rr[,2],
logor = log(smoking_b1_full$draws$or[,2]),
log2or = log2(smoking_b1_full$draws$or[,2])) %>%
pivot_longer(everything()) %>%
ggplot(aes(x = value, col = name))+
geom_density()
data.frame(or = smoking_b1_full$draws$or[,2],
rr = smoking_b1_full$draws$rr[,2],
logor = log(smoking_b1_full$draws$or[,2]),
log2or = log2(smoking_b1_full$draws$or[,2]),
log2rr = log2(smoking_b1_full$draws$rr[,2])) %>%
pivot_longer(everything()) %>%
ggplot(aes(x = value, col = name))+
geom_density()
