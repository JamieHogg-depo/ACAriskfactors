)) %>%
dplyr::select(bivariate_cat, DPP) %>%
setNames(c("bivariate_cat", "v"))
modelled_est <- readRDS(file = paste0("data/DataLabExport/modelled_est_", rf, ".rds"))
modelled_est$rr <- modelled_est$mu/raw_est[[k]]$national[1]
v <- bind_cols(getDPP(modelled_est$or, null_value = 1)) %>%
dplyr::select(EP, DPP) %>%
mutate(bivariate_cat = case_when(
EP >= 0.8 ~ "High",
EP <= 0.2 ~ "Low",
EP > 0.2 & EP < 0.8 ~ "Unclear"
)) %>%
dplyr::select(bivariate_cat, DPP) %>%
setNames(c("bivariate_cat", "v"))
v2 <- bind_cols(getDPP(modelled_est$rr, null_value = 1)) %>%
dplyr::select(EP, DPP) %>%
mutate(bivariate_cat = case_when(
EP >= 0.8 ~ "High",
EP <= 0.2 ~ "Low",
EP > 0.2 & EP < 0.8 ~ "Unclear"
)) %>%
dplyr::select(bivariate_cat, DPP) %>%
setNames(c("bivariate_cat", "v"))
head(v)
head(v2)
# Packages
library(tidyverse)
library(readr)
library(readxl)
library(sf)
library(openxlsx)
rm(list = ls())
## Functions ## ----------------------------------------------------------------
source('src/wrangle/functions_ALL.R')
source('src/wrangle/moreFuns.R')
# Load global data
global_obj <- readRDS("data/DataLabExport/global_obj.rds")
# Load raw estimates
raw_est <- pbapply::pblapply(list.files("data/DataLabExport",
pattern = "raw_est_*", full.names = T), readRDS)
names(raw_est) <- str_remove(
str_remove(
list.files("data/DataLabExport", pattern = "raw_est_*"), "raw_est_"), ".rds")
# load map
map_sa2_full <- st_read("C:/r_proj/ACAriskfactors/data/2016_SA2_Shape_min/2016_SA2_Shape_min.shp") %>%
mutate(SA2 = as.numeric(SA2_MAIN16)) %>%
filter(!str_detect(SA2_NAME, "Island")) %>%
filter(STATE_NAME != "Other Territories") %>%
dplyr::select(SA2_MAIN16, SA2_NAME) %>%
st_drop_geometry() %>%
rename(SA2 = SA2_MAIN16,
SA2_name = SA2_NAME) %>%
mutate(SA2 = as.numeric(SA2))
# Load all modelled estimates
summsa2all <- readRDS("data/summary_files/summsa2all.rds")
## START FOR LOOP #### ---------------------------------------------------------
out <- list()
for(k in 1:8){
rf <- names(raw_est)[k]
message("Started ", k, ": ", rf)
# load data
modelled_est <- readRDS(file = paste0("data/DataLabExport/modelled_est_", rf, ".rds"))
modelled_est$rr <- modelled_est$mu/raw_est[[k]]$national[1]
# get mu quantiles
mu_quants <- bind_rows(lapply(asplit(modelled_est$mu, 2),
quantile, p = c(0.1,0.2,0.5,0.8,0.9), na.rm = T)) %>%
setNames(paste0("mu_", c("p10", "p20", "p50", "p80", "p90")))
# get OR quantiles
or_quants <- bind_rows(lapply(asplit(modelled_est$or, 2),
quantile, p = c(0.1,0.2,0.5,0.8,0.9), na.rm = T)) %>%
setNames(paste0("or_", c("p10", "p20", "p50", "p80", "p90")))
# get logOR quantiles
logor_quants <- bind_rows(lapply(asplit(log(modelled_est$or), 2),
quantile, p = c(0.1,0.2,0.5,0.8,0.9), na.rm = T)) %>%
setNames(paste0("or_", c("logp10", "logp20", "logp50", "logp80", "logp90")))
# get OR quantiles
rr_quants <- bind_rows(lapply(asplit(modelled_est$rr, 2),
quantile, p = c(0.1,0.2,0.5,0.8,0.9), na.rm = T)) %>%
setNames(paste0("rr_", c("p10", "p20", "p50", "p80", "p90")))
# get logOR quantiles
logrr_quants <- bind_rows(lapply(asplit(log(modelled_est$rr), 2),
quantile, p = c(0.1,0.2,0.5,0.8,0.9), na.rm = T)) %>%
setNames(paste0("rr_", c("logp10", "logp20", "logp50", "logp80", "logp90")))
# get wave plot
or_wave <- getWavePlotVars(modelled_est$or, prefix = "or_")
rr_wave <- getWavePlotVars(modelled_est$rr, prefix = "rr_")
# V-plot - exceedance probability
v <- bind_cols(getDPP(modelled_est$or, null_value = 1)) %>%
dplyr::select(EP, DPP) %>%
mutate(bivariate_cat = case_when(
EP >= 0.8 ~ "High",
EP <= 0.2 ~ "Low",
EP > 0.2 & EP < 0.8 ~ "Unclear"
)) %>%
dplyr::select(bivariate_cat, DPP) %>%
setNames(c("bivariate_cat", "v"))
# add all colums
out[[k]] <- cbind(dplyr::select(global_obj$area_concor, SA2),
or_quants, logor_quants, or_wave,
v,
mu_quants,
rr_quants, logrr_quants, rr_wave) %>%
mutate(riskfactorgrp = rf) %>%
left_join(., map_sa2_full, by = "SA2") %>%
rename(SA2_code = SA2)
# cleanup
rm(modelled_est, mu_quants, or_quants, logor_quants, v, or_wave, rr_wave,
rr_quants, logrr_quants)
## FINISH FOR LOOP #### --------------------------------------------------------
}
# save R version
full_data <- bind_rows(out) %>%
mutate(indicator = "riskfactor",
level = "",
sex = "Persons",
years = "2017-2018",
baseline = "national_average") %>%
relocate(indicator, level, sex, riskfactorgrp, years, baseline, SA2_code, SA2_name)
saveRDS(full_data, "data/ViseR_Input_Data/riskfactor_estimates.rds")
# ORs
full_data %>%
dplyr::select(1:8, contains("or_"), v, bivariate_cat) %>%
write.csv(., "data/ViseR_Input_Data/riskfactor_estimates_or.csv")
# RRs
full_data %>%
dplyr::select(1:8, contains("rr_"), v, bivariate_cat) %>%
write.csv(., "data/ViseR_Input_Data/riskfactor_estimates_rr.csv")
any(summsa2all$mu_median < 0)
stop(any(summsa2all$mu_median < 0), "Ensure all posterior draws are positive...")
#' @title getWavePlotVars
#' @param draws matrix (iterations x observations) of posterior draws
#' @param prefix (defaults to "") character vector that will be appended to
#' the start of the column names.
#' @param verbose (defaults to FALSE) reports progress of operation.
#' @param truncation_upper (defaults to 4) truncation of density approximation of
#' ratios. With a value of 4, density evaluations above 4 and below 1/4 are removed.
#' @returns Dataframe (observations x 2) with `xValues` and `yValues`
#' #' WARNING: Only use with relative measures where 1 is a meaningful middle value.
#' #' NOTE: `draws` should NOT be log-transformed - the function will perform this action.
getWavePlotVars <- function(draws, prefix = "", verbose = FALSE, truncation_upper = 4){
if(draws < 0)
stop("Ensure all posterior draws are positive...")
# create empty data.frame
temp.wave <- NULL
# loop through each column of `draws`
if(verbose){pb <- txtProgressBar(min = 0, max = ncol(draws), style = 3)}
for(i in 1:ncol(draws)){
# set truncation amount
truncation <- c(1/truncation_upper, truncation_upper)
# Initial density estimation
f <- density(log(draws[,i]), n = 128)
x.out <- f$x
y.out <- f$y
# truncate densities
keep <- which(x.out > log(truncation[1]) & x.out < log(truncation[2]))
# select points
if(length(keep) > 0){
x.out <- x.out[keep]
y.out <- y.out[keep]
# Identify mode and points at strategic y values
n2 <- length(x.out)
Mode <- which.max(y.out)
h85 <- abs(y.out[Mode] * 0.85 - y.out)
h10 <- abs(y.out[Mode] * 0.1 - y.out)
zeros <- y.out
zeros[which(zeros < y.out[Mode] * 0.002)] <- Inf
# Set left points
if(Mode == 1){
h85.L <- Mode
h10.L <- Mode
Min <- Mode
}else{
h85.L <- which.min(h85[1:(Mode - 1)])
h10.L <- which.min(h10[1:(Mode - 1)])
Min <- which.min(zeros[1:(Mode - 1)])
}
# Set right points
if(Mode == n2){
h85.R <- Mode
h10.R <- Mode
Max <- Mode
}else{
h85.R <- which.min(h85[(Mode + 1):n2]) + Mode
h10.R <- which.min(h10[(Mode + 1):n2]) + Mode
Max <- which.min(zeros[(Mode + 1):n2]) + Mode
}
keep <- c(Min, h10.L, h85.L, Mode, h85.R, h10.R, Max)
}else{
keep <- which.max(y.out)
if(keep < n){   # Stack at lower truncation
keep <- 1:7
x.out <- rep(log(truncation[1]), 7)
}else{          # Stack at upper truncation
keep <- (n-6):n
x.out <- rep(log(truncation[2]), 7)
}
y.out <- y.out[keep]
}
# Reduce to 7 points
x.out <- x.out[keep]
y.out <- y.out[keep]
# Duplicate end value with zero y values to ensure correct shading of wave plot
x.out <- c(x.out[1], x.out, x.out[7])
y.out <- c(0, y.out, 0)
# add to dataset
temp.wave <- rbind(temp.wave, c(x.out, y.out))
# progress bar
if(verbose)setTxtProgressBar(pb, i)
} # end for loop
if(verbose)close(pb)
# Round wave x-values to 2 dp
temp.wave[, 1:9] <- sapply(temp.wave[, 1:9], round, digits = 2)
# Round wave y-values to 3 dp
temp.wave[, 10:18] <- sapply(temp.wave[, 10:18], round, digits = 3)
# Concatenate wave x and y values into strings
temp1 <- apply(temp.wave[,1:9], 1, paste, collapse = ",")
temp2 <- apply(temp.wave[,10:18], 1, paste, collapse = ",")
temp.wave <- cbind(temp1, temp2)
colnames(temp.wave) <- c("xValues", "yValues")
# return dataframe
return(as.data.frame(temp.wave) %>% setNames(paste0(prefix, names(.))))
}
getWavePlotVars(matrix(rnorm(10), ncol = 5))
getWavePlotVars(matrix(runif(10000), ncol = 5))
#' @title getWavePlotVars
#' @param draws matrix (iterations x observations) of posterior draws
#' @param prefix (defaults to "") character vector that will be appended to
#' the start of the column names.
#' @param verbose (defaults to FALSE) reports progress of operation.
#' @param truncation_upper (defaults to 4) truncation of density approximation of
#' ratios. With a value of 4, density evaluations above 4 and below 1/4 are removed.
#' @returns Dataframe (observations x 2) with `xValues` and `yValues`
#' #' WARNING: Only use with relative measures where 1 is a meaningful middle value.
#' #' NOTE: `draws` should NOT be log-transformed - the function will perform this action.
getWavePlotVars <- function(draws, prefix = "", verbose = FALSE, truncation_upper = 4){
if(any(draws < 0))
stop("Ensure all posterior draws are positive...")
# create empty data.frame
temp.wave <- NULL
# loop through each column of `draws`
if(verbose){pb <- txtProgressBar(min = 0, max = ncol(draws), style = 3)}
for(i in 1:ncol(draws)){
# set truncation amount
truncation <- c(1/truncation_upper, truncation_upper)
# Initial density estimation
f <- density(log(draws[,i]), n = 128)
x.out <- f$x
y.out <- f$y
# truncate densities
keep <- which(x.out > log(truncation[1]) & x.out < log(truncation[2]))
# select points
if(length(keep) > 0){
x.out <- x.out[keep]
y.out <- y.out[keep]
# Identify mode and points at strategic y values
n2 <- length(x.out)
Mode <- which.max(y.out)
h85 <- abs(y.out[Mode] * 0.85 - y.out)
h10 <- abs(y.out[Mode] * 0.1 - y.out)
zeros <- y.out
zeros[which(zeros < y.out[Mode] * 0.002)] <- Inf
# Set left points
if(Mode == 1){
h85.L <- Mode
h10.L <- Mode
Min <- Mode
}else{
h85.L <- which.min(h85[1:(Mode - 1)])
h10.L <- which.min(h10[1:(Mode - 1)])
Min <- which.min(zeros[1:(Mode - 1)])
}
# Set right points
if(Mode == n2){
h85.R <- Mode
h10.R <- Mode
Max <- Mode
}else{
h85.R <- which.min(h85[(Mode + 1):n2]) + Mode
h10.R <- which.min(h10[(Mode + 1):n2]) + Mode
Max <- which.min(zeros[(Mode + 1):n2]) + Mode
}
keep <- c(Min, h10.L, h85.L, Mode, h85.R, h10.R, Max)
}else{
keep <- which.max(y.out)
if(keep < n){   # Stack at lower truncation
keep <- 1:7
x.out <- rep(log(truncation[1]), 7)
}else{          # Stack at upper truncation
keep <- (n-6):n
x.out <- rep(log(truncation[2]), 7)
}
y.out <- y.out[keep]
}
# Reduce to 7 points
x.out <- x.out[keep]
y.out <- y.out[keep]
# Duplicate end value with zero y values to ensure correct shading of wave plot
x.out <- c(x.out[1], x.out, x.out[7])
y.out <- c(0, y.out, 0)
# add to dataset
temp.wave <- rbind(temp.wave, c(x.out, y.out))
# progress bar
if(verbose)setTxtProgressBar(pb, i)
} # end for loop
if(verbose)close(pb)
# Round wave x-values to 2 dp
temp.wave[, 1:9] <- sapply(temp.wave[, 1:9], round, digits = 2)
# Round wave y-values to 3 dp
temp.wave[, 10:18] <- sapply(temp.wave[, 10:18], round, digits = 3)
# Concatenate wave x and y values into strings
temp1 <- apply(temp.wave[,1:9], 1, paste, collapse = ",")
temp2 <- apply(temp.wave[,10:18], 1, paste, collapse = ",")
temp.wave <- cbind(temp1, temp2)
colnames(temp.wave) <- c("xValues", "yValues")
# return dataframe
return(as.data.frame(temp.wave) %>% setNames(paste0(prefix, names(.))))
}
getWavePlotVars(matrix(runif(10000), ncol = 5))
getWavePlotVars(matrix(runif(10000, -1, 1), ncol = 5))
#' @title getWavePlotVars
#' @param draws matrix (iterations x observations) of posterior draws
#' @param prefix (defaults to "") character vector that will be appended to
#' the start of the column names.
#' @param verbose (defaults to FALSE) reports progress of operation.
#' @param truncation_upper (defaults to 4) truncation of density approximation of
#' ratios. With a value of 4, density evaluations above 4 and below 1/4 are removed.
#' @returns Dataframe (observations x 2) with `xValues` and `yValues`
#' #' WARNING: Only use with relative measures where 1 is a meaningful middle value.
#' #' NOTE: `draws` should NOT be log-transformed - the function will perform this action.
getWavePlotVars <- function(draws, prefix = "", verbose = FALSE, truncation_upper = 4){
if(any(draws < 0))
stop(paste0("Ensure all values in ", deparse(substitute(draws)), " are positive..."))
# create empty data.frame
temp.wave <- NULL
# loop through each column of `draws`
if(verbose){pb <- txtProgressBar(min = 0, max = ncol(draws), style = 3)}
for(i in 1:ncol(draws)){
# set truncation amount
truncation <- c(1/truncation_upper, truncation_upper)
# Initial density estimation
f <- density(log(draws[,i]), n = 128)
x.out <- f$x
y.out <- f$y
# truncate densities
keep <- which(x.out > log(truncation[1]) & x.out < log(truncation[2]))
# select points
if(length(keep) > 0){
x.out <- x.out[keep]
y.out <- y.out[keep]
# Identify mode and points at strategic y values
n2 <- length(x.out)
Mode <- which.max(y.out)
h85 <- abs(y.out[Mode] * 0.85 - y.out)
h10 <- abs(y.out[Mode] * 0.1 - y.out)
zeros <- y.out
zeros[which(zeros < y.out[Mode] * 0.002)] <- Inf
# Set left points
if(Mode == 1){
h85.L <- Mode
h10.L <- Mode
Min <- Mode
}else{
h85.L <- which.min(h85[1:(Mode - 1)])
h10.L <- which.min(h10[1:(Mode - 1)])
Min <- which.min(zeros[1:(Mode - 1)])
}
# Set right points
if(Mode == n2){
h85.R <- Mode
h10.R <- Mode
Max <- Mode
}else{
h85.R <- which.min(h85[(Mode + 1):n2]) + Mode
h10.R <- which.min(h10[(Mode + 1):n2]) + Mode
Max <- which.min(zeros[(Mode + 1):n2]) + Mode
}
keep <- c(Min, h10.L, h85.L, Mode, h85.R, h10.R, Max)
}else{
keep <- which.max(y.out)
if(keep < n){   # Stack at lower truncation
keep <- 1:7
x.out <- rep(log(truncation[1]), 7)
}else{          # Stack at upper truncation
keep <- (n-6):n
x.out <- rep(log(truncation[2]), 7)
}
y.out <- y.out[keep]
}
# Reduce to 7 points
x.out <- x.out[keep]
y.out <- y.out[keep]
# Duplicate end value with zero y values to ensure correct shading of wave plot
x.out <- c(x.out[1], x.out, x.out[7])
y.out <- c(0, y.out, 0)
# add to dataset
temp.wave <- rbind(temp.wave, c(x.out, y.out))
# progress bar
if(verbose)setTxtProgressBar(pb, i)
} # end for loop
if(verbose)close(pb)
# Round wave x-values to 2 dp
temp.wave[, 1:9] <- sapply(temp.wave[, 1:9], round, digits = 2)
# Round wave y-values to 3 dp
temp.wave[, 10:18] <- sapply(temp.wave[, 10:18], round, digits = 3)
# Concatenate wave x and y values into strings
temp1 <- apply(temp.wave[,1:9], 1, paste, collapse = ",")
temp2 <- apply(temp.wave[,10:18], 1, paste, collapse = ",")
temp.wave <- cbind(temp1, temp2)
colnames(temp.wave) <- c("xValues", "yValues")
# return dataframe
return(as.data.frame(temp.wave) %>% setNames(paste0(prefix, names(.))))
}
getWavePlotVars(matrix(runif(10000, -1, 1), ncol = 5))
getWavePlotVars(test <- matrix(runif(10000, -1, 1), ncol = 5))
test <- matrix(runif(10000, -1, 1), ncol = 5)
getWavePlotVars(test)
#' @title getWavePlotVars
#' @param draws matrix (iterations x observations) of posterior draws
#' @param prefix (defaults to "") character vector that will be appended to
#' the start of the column names.
#' @param verbose (defaults to FALSE) reports progress of operation.
#' @param truncation_upper (defaults to 4) truncation of density approximation of
#' ratios. With a value of 4, density evaluations above 4 and below 1/4 are removed.
#' @returns Dataframe (observations x 2) with `xValues` and `yValues`
#' #' WARNING: Only use with relative measures where 1 is a meaningful middle value.
#' #' NOTE: `draws` should NOT be log-transformed - the function will perform this action.
getWavePlotVars <- function(draws, prefix = "", verbose = FALSE, truncation_upper = 4){
if(any(draws < 0))
stop(paste0("Ensure all values in `", deparse(substitute(draws)), "` are positive..."))
# create empty data.frame
temp.wave <- NULL
# loop through each column of `draws`
if(verbose){pb <- txtProgressBar(min = 0, max = ncol(draws), style = 3)}
for(i in 1:ncol(draws)){
# set truncation amount
truncation <- c(1/truncation_upper, truncation_upper)
# Initial density estimation
f <- density(log(draws[,i]), n = 128)
x.out <- f$x
y.out <- f$y
# truncate densities
keep <- which(x.out > log(truncation[1]) & x.out < log(truncation[2]))
# select points
if(length(keep) > 0){
x.out <- x.out[keep]
y.out <- y.out[keep]
# Identify mode and points at strategic y values
n2 <- length(x.out)
Mode <- which.max(y.out)
h85 <- abs(y.out[Mode] * 0.85 - y.out)
h10 <- abs(y.out[Mode] * 0.1 - y.out)
zeros <- y.out
zeros[which(zeros < y.out[Mode] * 0.002)] <- Inf
# Set left points
if(Mode == 1){
h85.L <- Mode
h10.L <- Mode
Min <- Mode
}else{
h85.L <- which.min(h85[1:(Mode - 1)])
h10.L <- which.min(h10[1:(Mode - 1)])
Min <- which.min(zeros[1:(Mode - 1)])
}
# Set right points
if(Mode == n2){
h85.R <- Mode
h10.R <- Mode
Max <- Mode
}else{
h85.R <- which.min(h85[(Mode + 1):n2]) + Mode
h10.R <- which.min(h10[(Mode + 1):n2]) + Mode
Max <- which.min(zeros[(Mode + 1):n2]) + Mode
}
keep <- c(Min, h10.L, h85.L, Mode, h85.R, h10.R, Max)
}else{
keep <- which.max(y.out)
if(keep < n){   # Stack at lower truncation
keep <- 1:7
x.out <- rep(log(truncation[1]), 7)
}else{          # Stack at upper truncation
keep <- (n-6):n
x.out <- rep(log(truncation[2]), 7)
}
y.out <- y.out[keep]
}
# Reduce to 7 points
x.out <- x.out[keep]
y.out <- y.out[keep]
# Duplicate end value with zero y values to ensure correct shading of wave plot
x.out <- c(x.out[1], x.out, x.out[7])
y.out <- c(0, y.out, 0)
# add to dataset
temp.wave <- rbind(temp.wave, c(x.out, y.out))
# progress bar
if(verbose)setTxtProgressBar(pb, i)
} # end for loop
if(verbose)close(pb)
# Round wave x-values to 2 dp
temp.wave[, 1:9] <- sapply(temp.wave[, 1:9], round, digits = 2)
# Round wave y-values to 3 dp
temp.wave[, 10:18] <- sapply(temp.wave[, 10:18], round, digits = 3)
# Concatenate wave x and y values into strings
temp1 <- apply(temp.wave[,1:9], 1, paste, collapse = ",")
temp2 <- apply(temp.wave[,10:18], 1, paste, collapse = ",")
temp.wave <- cbind(temp1, temp2)
colnames(temp.wave) <- c("xValues", "yValues")
# return dataframe
return(as.data.frame(temp.wave) %>% setNames(paste0(prefix, names(.))))
}
getWavePlotVars(test)
test <- matrix(runif(10000), ncol = 5)
getWavePlotVars(test)
